package org.yanzhe.inteliticket.core.algo;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.SortedSet;
import java.util.TreeSet;
import org.jetbrains.annotations.NotNull;
import org.yanzhe.inteliticket.core.graph.AbstractAdjacentListGraph;
import org.yanzhe.inteliticket.core.graph.DirectWeightedEdge;
import org.yanzhe.inteliticket.core.graph.GPath;

public class YenKSP<ET extends DirectWeightedEdge> implements PathProvider<ET> {

  private int K;

  public YenKSP(int K) {
    this.K = K;
  }

  @NotNull
  @Override
  public List<GPath<ET>> providePaths(@NotNull AbstractAdjacentListGraph<ET> graph, int src,
      int dst) {
    //    DefaultAdjacentListGraph<ET> graph = new DefaultAdjacentListGraph<>(graph);
    // Initialize containers for candidate paths and k shortest paths
    List<GPath<ET>> ksp = new ArrayList<>();
    PriorityQueue<GPath<ET>> candidates = new PriorityQueue<>();
    SortedSet<Double> seenWeights = new TreeSet<>();

    try {
      /* Compute and add the shortest path */
      List<GPath<ET>> initDijP = new DijkstraSP<ET>().providePaths(graph, src, dst);
      GPath<ET> kthPath = initDijP.size() == 0 ? null : initDijP.get(0);
      ksp.add(kthPath);

      /* Iteratively compute each of the k shortest paths */
      for (int k = 1; k < K; k++) {
        // Get the (k-1)st shortest path
        GPath<ET> previousPath = ksp.get(k - 1);

        /* Iterate over all of the nodes in the (k-1)st shortest path except for the target node; for each node,
        (up to) one new candidate path is generated by temporarily modifying the graph and then running
        Dijkstra's algorithm to find the shortest path between the node and the target in the modified
        graph */
        for (int i = 0; i < previousPath.size(); i++) {
          // Initialize a container to store the modified (removed) edges for this node/iteration
          LinkedList<ET> removedEdges = new LinkedList<>();

          // Spur node = currently visited node in the (k-1)st shortest path
          int spurNode = previousPath.getEdge(i).from();

          // Root path = prefix portion of the (k-1)st path up to the spur node
          GPath<ET> rootPath = previousPath.cloneTo(i);

          /* Iterate over all of the (k-1) shortest paths */
          for (GPath<ET> p : ksp) {
            GPath<ET> stub = p.cloneTo(i);
            // Check to see if this path has the same prefix/root as the (k-1)st shortest path
            if (rootPath.equals(stub)) {
              /* If so, eliminate the next edge in the path from the graph (later on, this forces the spur
              node to connect the root path with an un-found suffix path) */
              ET re = p.getEdge(i);
              graph.removeEdge(re.from(), re.to());
              removedEdges.add(re);
            }
          }

          /* Temporarily remove all of the nodes in the root path, other than the spur node, from the graph */
          for (ET rootPathEdge : rootPath.getEdges()) {
            int rn = rootPathEdge.from();
            if (rn != spurNode) {
              removedEdges.addAll(graph.removeNode(rn));
            }
          }

          // Spur path = shortest path from spur node to target node in the reduced graph

          List<GPath<ET>> spurDijP = new DijkstraSP<ET>().providePaths(graph, spurNode, dst);
          GPath<ET> spurPath = spurDijP.size() == 0 ? null : spurDijP.get(0);

          // If a new spur path was identified...
          if (spurPath != null) {
            // Concatenate the root and spur paths to form the new candidate path
            GPath<ET> totalPath = new GPath<>(rootPath);
            totalPath.addPath(spurPath);

            // If candidate path has not been generated previously, add it
            if (!candidates.contains(totalPath)) {
              double curWeight = totalPath.getWeight();
              if (!seenWeights.contains(curWeight)) {
                candidates.add(totalPath);
                seenWeights.add(curWeight);
              }
            }
          }

          // Restore all of the edges that were removed during this iteration
          graph.addEdges(removedEdges);
        }
        /* Identify the candidate path with the shortest cost */
        boolean isNewPath;
        do {
          kthPath = candidates.poll();
          isNewPath = true;
          if (kthPath != null) {
            for (GPath<ET> p : ksp) {
              // Check to see if this candidate path duplicates a previously found path
              if (p.equals(kthPath)) {
                isNewPath = false;
                break;
              }
            }
          }
        } while (!isNewPath);

        // If there were not any more candidates, stop
        if (kthPath == null) {
          break;
        }

        // Add the best, non-duplicate candidate identified as the k shortest path
        ksp.add(kthPath);
      }
    } catch (Exception e) {
      e.printStackTrace();
    }

    // Return the set of k shortest paths
    return ksp;
  }
}
